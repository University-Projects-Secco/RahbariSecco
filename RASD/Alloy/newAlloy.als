open util/boolean

sig Citizen{
	sent: set Notification,
	acked: set Notification
}

sig Authority{
	releasedPermissions: set Permission,
	knownPermission: set Permission
}

sig Permission{
	type: one ViolType,
	plate: one Plate
}

sig Violation{
	pic: one Picture,
	date: one Date,
	t: one Time,
	loc: one Location,
	type: one ViolType
}{
	(no disj v1,v2: Violation | extractData[v1] = extractData[v2])	//No duplicated violations
}

sig Notification{
	viol: Violation,
	data: set Data,
	modified: Bool
}{
	(modified = True => (some n:Notification | this!=n and modify[n,this]) else (data = extractData[viol]))	//no self-generated modified tasks, new notifications are generated by a violation
and	fullData[this]
}

sig Ticket{
	viol: one Violation,
	notif: lone Notification,
	plate: one Plate,
	releasedBy: one Authority
}{
	plate = viol.pic.plate
}

sig Statistic{}

sig Plate{}

abstract sig Data{}
sig Picture extends Data{plate: lone Plate}	//empty uf plate cannot be retrived
sig Date extends Data{}
sig Time extends Data{}
sig Location extends Data{}
enum ViolType{t1,t2,t3}

//GOALS:
//G1: Allow citizens to notify parking violations and be acknowledged of the result as soon as possible
//For the functional part, enforce this function:
assert G1{
	(some n: Notification | not n.data = none) => (some n: Notification, v: Violation | n.viol = v and n.data = extractData[v] and n.modified=False)
}

//G2: check every notification has full data
assert G2{
	all n: Notification | fullData[n]
}

//G3: undefinable

//G4: Ensure no tickets can be emitted if the notification's data has been modified somehow
assert G4{
	no t: Ticket, n: Notification | t = generateTicket[n] and n.modified = True
}

//G5: Ensure no tickets can be emitted if the plate of the car that committed the infringment owns a permission for that infringiment
assert G5{
	no t: Ticket | let p=t.plate | some per: Permission | per.type = t.viol.type and per.plate = p
}

//G6: Every notification not covered by G4 or G5 will be eligible for ticket generation
assert G6{
//	all n: Notification | (n is not modified and the plate in n does not have a permission for n) implies (some t: Ticket related to n)
}

//G7: Allow both citizens and authorities retrive informations about previous violations and released tickets, possibly in an aggregated form 
assert G7{
//	all n:Notification, t:Ticket | some s: Statistic | n in s and t in s
}

//REQUIREMENTS

//ASSUMPTION
//Every valid violation generates a ticket (only used for formal analysis)


//CONSTRAINTS

//PREDICATES
pred modify[n,n':Notification]{	//True iff the notification has been modified
	n.viol = n'.viol and not n.data=n'.data and n'.modified=True and n.modified = False
}

pred fullData[n:Notification]{	//true iff the notification contains all the required data
	(some p: Picture | p in n.data) and
	(some d: Date | d in n.data) and
	(some t: Time | t in n.data) and
	(some l: Location | l in n.data)
}

pred notify[c,c': Citizen,v: Violation,n:Notification]{
	//c' is c after notification and ack, n is the notification generated by v
	n.viol = v and n.data = extractData[v]
}

//FUNCTIONS
fun extractData[v:Violation]: set Data{
	v.pic + v.date + v.t + v.loc
}

fun generateTicket[n: Notification]: lone Ticket{
	{t: Ticket | t.viol = n.viol and t.notif = n and t.plate = n.viol.pic.plate}
}

//check G1 for 10
//check G2 for 10
	//check G3
check G4 for 10
check G5 for 10
run modify for 5
