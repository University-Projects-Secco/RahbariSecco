open util/boolean

sig Citizen{
	sent: set Notification,
	acked: set Notification
}

sig Violation{
	pic: Picture,
	date: Date,
	t: Time,
	loc: Location
}{
	no disj v1,v2: Violation | extractData[v1] = extractData[v2]
}

sig Notification{
	viol: Violation,
	data: set Data,
	modified: Bool
}{
	(modified = True) => (some n:Notification | this!=n and modify[n,this]) else (data = extractData[viol])	//no self-generated modified tasks
	//new notifications are generated by a violation
	
}

sig Ticket{

}

sig Statistic{}

abstract sig Data{}
sig Picture extends Data{}
sig Date extends Data{}
sig Time extends Data{}
sig Location extends Data{}

//GOALS:
//G1: Allow citizens to notify parking violations and be acknowledged of the result as soon as possible
//For the functional part, enforce this function:

//G2: check every notification has full data
assert G2{
	all n: Notification | fullData[n]
}

//G3: undefinable

//G4: Ensure no tickets can be emitted if the notification's data has been modified somehow
assert G4{
//	no t: Ticket, n:Notification | t is built from n and n is modified
}

//G5: Ensure no tickets can be emitted if the plate of the car that committed the infringment owns a permission for that infringiment
assert G5{
//	no t: Ticket, p: Plate | t is for p and p has a permission for the violation which generated the ticket
}

//G6: Every notification not covered by G4 or G5 will be eligible for ticket generation
assert G6{
//	all n: Notification | (n is not modified and the plate in n does not have a permission for n) implies (some t: Ticket related to n)
}

//G7: Allow both citizens and authorities retrive informations about previous violations and released tickets, possibly in an aggregated form 
assert G7{
//	all n:Notification, t:Ticket | some s: Statistic | n in s and t in s
}

//REQUIREMENTS

//ASSUMPTION
//Every valid violation generates a ticket (only used for formal analysis)

//CONSTRAINTS

//PREDICATES
pred modify[n,n':Notification]{	//True iff the notification has been modified
	n.viol = n'.viol and not n.data=n'.data and n'.modified=True and n.modified = False
}

pred fullData[n:Notification]{	//true iff the notification contains all the required data
	(some p: Picture | p in n.data) and
	(some d: Date | d in n.data) and
	(some t: Time | t in n.data) and
	(some l: Location | l in n.data)
}

pred notify[c,c': Citizen,v: Violation,n:Notification]{
	//c' is c after notification and ack, n is the notification generated by v
	n.viol = v and n.data = extractData[v]
}

//FUNCTIONS
fun extractData[v:Violation]: set Data{
	v.pic + v.date + v.t + v.loc
}



run {} for 4 but exactly 2 Notification
