open util/boolean

sig Citizen{
	sent: set Notification,
	acked: set Notification,
	nacked: set Notification,
	plates: set Plate
}{
	acked in sent and nacked in sent and acked&nacked=none 
}

sig Authority{
	releasedPermissions: set Permission,
	knownPermissions: set Permission
}{
	releasedPermissions in knownPermissions
}

sig Permission{
	type: one ViolType,
	plate: one Plate
}{
	some a: Authority | this in a.releasedPermissions
}

one sig SafeStreets{
	knownPermissions: set Permission,
	knownTickets: set Ticket,
	storedNotifications: set Notification
}

sig Violation{
	pic: one Picture,
	date: one Date,
	t: one Time,
	loc: one Location,
	type: one ViolType
}{
	(no disj v1,v2: Violation | extractData[v1] = extractData[v2]) 	//No duplicated violations
and	(some n:Notification | n.viol = this)	//all violations are notified (useless to consider unnoticed ones)
}

sig Notification{
	viol: Violation,
	data: set Data,
	modified: Bool
}{
	(modified = True => (some n:Notification | this!=n and modify[n,this]) else (data = extractData[viol])) //A5,A6: no self-generated modified tasks, new notifications are generated by a violation
and	fullData[this]
and	(one c: Citizen | this in c.sent)
}

sig Ticket{
	viol: one Violation,
	notif: lone Notification,
	plate: one Plate,
	releasedBy: one Authority
}{
	some n:Notification | this=generateTicket[n] and
	notif in SafeStreets.storedNotifications //A7: If a notification is not stored then no auth can see it and therefore no ticket can be released for that notification
}

sig Statistic{
	violations: set Violation
}{
	#violations>0
}

sig Plate{}

abstract sig Data{}
sig Picture extends Data{plate: lone Plate}	//empty if plate cannot be retrived
sig Date extends Data{}
sig Time extends Data{}
sig Location extends Data{}
enum ViolType{t1,t2,t3}

//GOALS:
//G1: Allow citizens to notify parking violations and be acknowledged of the result as soon as possible
//For the functional part, enforce this function:
assert G1{
	(#Notification>0) => (some n: Notification, v: Violation | n.modified=False and n.viol = v and n.data = extractData[v])
}

//G2: check every notification has full data
assert G2{
	all n: Notification | fullData[n]
}

//G3: check if there's a violation it is stored
assert G3{
	#Violation>0 => #SafeStreets.storedNotifications>0
}


//G4: Ensure no tickets can be emitted if the notification's data has been modified somehow
assert G4{
	no t: Ticket, n: Notification | t = generateTicket[n] and n.modified = True
}

//G5: Ensure no tickets can be emitted if the plate of the car that committed the infringment owns a permission for that infringiment
assert G5{
	no t: Ticket | some per: Permission | per.type = t.viol.type and per.plate = t.plate
}

//G6: Every notification not covered by G4 or G5 will be eligible for ticket generation
assert G6{
	#Authority>0 implies all n:Notification | (n.modified=False and no p:Permission | (p.type=n.viol.type and (some pic:Picture | pic in n.data and pic.plate=p.plate))) implies
		(some t:Ticket | t=generateTicket[n])
}

//G7: Allow both citizens and authorities retrive informations about previous violations and released tickets, possibly in an aggregated form. Every violation reported to the system and stored will appear in some statistics
assert G7{
	all v: Violation | some s: Statistic | (v in s.violations <=> some n:Notification | n in SafeStreets.storedNotifications and n.viol = v)
}

//REQUIREMENTS
fact R1{//Requires the authorities to give safestreets informations about the ticket they release using the system
	all t:Ticket | t in SafeStreets.knownTickets
}

fact R2{//Automatically extract the plate number of the car from the photo, ignoring cars in the background if present
	no n:Notification | some p:Picture | (p in n.data and p.plate=none)
}

fact R3{//Ensure no data is altered from the insertion to the eventual storage
	no n:Notification | (n in SafeStreets.storedNotifications and n.modified = True)
}
//R4 helps but is not strictly needed for meeting the goals

//R7 R8 R9 are enforced by the "store" function
fact enforceStore{
	all n:Notification | store[n]	
}

fact enforceGenerateStat{
	(all s:Statistic | some l:Location | s=generateStats[l]) and 
	all l:Location | some s:Statistic | s=generateStats[l]
}

//ASSUMPTION
//Every "valid" violation generates a ticket (only used for formal analysis)
fact everyNotificationStoredGeneratesATicket{
	all n:Notification | n in SafeStreets.storedNotifications implies some t:Ticket | t=generateTicket[n]
}

fact noDuplicatedNotifications{
	no disj n1,n2: Notification | n1.viol = n2.viol and some c:Citizen | n1 in c.sent and n2 in c.sent
}

fact noDuplicatedPermissions{
	no disj p1,p2: Permission | p1.type=p2.type and p1.plate=p2.plate
}

fact A1{
	no p:Plate | some disj c1,c2:Citizen | p in c1.plates and p in c2.plates
}

//A1, A2, A3 allows to ignore the definition of Car (as it is uniquely identified from its plate)
fact A4{//SafeStreets will have access to any permission released by the auths
	(no p: Permission | some a: Authority | not p in a.knownPermissions)
	and
	(all p: Permission | p in SafeStreets.knownPermissions)
}

//PREDICATES
pred modify[n,n':Notification]{	//Models the function of modifiyng a notification
	n.viol = n'.viol and not n.data=n'.data and n'.modified=True and n.modified = False
}

pred fullData[n:Notification]{	//true iff the notification contains all the required data (true even if more data are inserted)
	(some p: Picture | p in n.data) and
	(some d: Date | d in n.data) and
	(some t: Time | t in n.data) and
	(some l: Location | l in n.data)
}

pred notify[c,c': Citizen,v: Violation,n:Notification]{
	//c' is c after notification is sent, n is the notification generated by v
	n.viol = v and n.data = extractData[v] and n in c'.sent and not n in c.sent
}

pred store[n:Notification]{//models the checking of a notification and the eventual storage
	(n in SafeStreets.storedNotifications)<=> n.modified=False 
							and (no p:Permission |	(p.type=n.viol.type and
										 	(some pic:Picture | pic in n.data and pic.plate=p.plate)))
							and (all c:Citizen | n in c.sent => n in c.acked)
}

//FUNCTIONS
fun extractData[v:Violation]: set Data{
	v.pic + v.date + v.t + v.loc
}

fun generateTicket[n: Notification]: lone Ticket{
	{t: Ticket | t.viol = n.viol and t.notif = n and t.plate = n.viol.pic.plate}
}

fun generateStats[l: Location]: one Statistic{
	{s: Statistic | all v: Violation | (v in s.violations <=> (v.loc = l and some n:Notification | (n.viol = v and n in SafeStreets.storedNotifications))) }
}

//WORLDS
pred W1{

}

//check G1 for 10
//check G2 for 10
//check G3 for 10
//check G4 for 10
check G5 for 10
//check G6 for 10
check G7 for 10
